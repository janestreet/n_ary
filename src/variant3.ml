(* This file is automatically generated.  Do not edit it directly. *)

open! Base

type ('a0, 'a1, 'a2) t =
  | Case0 of 'a0
  | Case1 of 'a1
  | Case2 of 'a2
[@@deriving compare, equal, hash, sexp_of]

(* constructors *)

let case0 x = Case0 x
let case1 x = Case1 x
let case2 x = Case2 x

(* predicates *)

let is_case0 = function
  | Case0 _ -> true
  | _ -> false
;;

let is_case1 = function
  | Case1 _ -> true
  | _ -> false
;;

let is_case2 = function
  | Case2 _ -> true
  | _ -> false
;;

(* accessors *)

let get_case0 = function
  | Case0 x -> Some x
  | _ -> None
;;

let get_case1 = function
  | Case1 x -> Some x
  | _ -> None
;;

let get_case2 = function
  | Case2 x -> Some x
  | _ -> None
;;

(* raising accessors *)

let get_case0_exn = function
  | Case0 x -> x
  | _ -> raise_s [%message "N_ary.Variant3.get_case0_exn: invalid input"]
;;

let get_case1_exn = function
  | Case1 x -> x
  | _ -> raise_s [%message "N_ary.Variant3.get_case1_exn: invalid input"]
;;

let get_case2_exn = function
  | Case2 x -> x
  | _ -> raise_s [%message "N_ary.Variant3.get_case2_exn: invalid input"]
;;

(* map all cases *)

let map t ~f0 ~f1 ~f2 =
  match t with
  | Case0 x0 -> Case0 (f0 x0)
  | Case1 x1 -> Case1 (f1 x1)
  | Case2 x2 -> Case2 (f2 x2)
;;

(* map each case *)

let map_case0 t ~f =
  match t with
  | Case0 x -> Case0 (f x)
  | (Case1 _ | Case2 _) as t -> t
;;

let map_case1 t ~f =
  match t with
  | Case1 x -> Case1 (f x)
  | (Case0 _ | Case2 _) as t -> t
;;

let map_case2 t ~f =
  match t with
  | Case2 x -> Case2 (f x)
  | (Case0 _ | Case1 _) as t -> t
;;
